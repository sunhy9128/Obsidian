#Tensorflow
![卷积过程](https://tf.wiki/_images/cnn.png)
```python
class CNN(tf.keras.Model):
    def __init__(self): 
		super().__init__() 
		self.conv1 = tf.keras.layers.Conv2D(
            filters=32, # 卷积层神经元（卷积核）数目 
			kernel_size=[5, 5], # 感受野大小 
			padding='same', # padding策略（vaild 或 same） 
			activation=tf.nn.relu # 激活函数 ) 
			self.pool1 = tf.keras.layers.MaxPool2D(pool_size=[2, 2], strides=2) 
			self.conv2 = tf.keras.layers.Conv2D(
            	filters=64,
            	kernel_size=[5, 5],
            	padding='same',
            	activation=tf.nn.relu
        	) 
			self.pool2 = tf.keras.layers.MaxPool2D(pool_size=[2, 2], strides=2) 
			self.flatten = tf.keras.layers.Reshape(target_shape=(7 * 7 * 64,)) 
			self.dense1 = tf.keras.layers.Dense(units=1024, activation=tf.nn.relu) 
			self.dense2 = tf.keras.layers.Dense(units=10) 
	def call(self, inputs):
        x = self.conv1(inputs) # [batch_size, 28, 28, 32] 
		x = self.pool1(x) # [batch_size, 14, 14, 32] 
		x = self.conv2(x) # [batch_size, 14, 14, 64] 
		x = self.pool2(x) # [batch_size, 7, 7, 64] 
		x = self.flatten(x) # [batch_size, 7 * 7 * 64] 
		x = self.dense1(x) # [batch_size, 1024] 
		x = self.dense2(x) # [batch_size, 10] 
		output = tf.nn.softmax(x) return output
```
![卷积核感受野](https://tf.wiki/_images/conv_procedure.png)

> 按照上述介绍的方法，每次卷积后的结果相比于原始图像而言，四周都会 “少一圈”。比如上面 7×7 的图像，卷积后变成了 5×5 ，这有时会为后面的工作带来麻烦。因此，我们可以设定 padding 策略。在 `tf.keras.layers.Conv2D` 中，当我们将 `padding` 参数设为 `same` 时，会将周围缺少的部分使用 0 补齐，使得输出的矩阵大小和输入一致。